// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#ifndef msr_airlib_JSBSimPhysicsBody_hpp
#define msr_airlib_JSBSimPhysicsBody_hpp

#include "common/Common.hpp"
#include "common/CommonStructs.hpp"
#include "vehicles/multirotor/RotorActuator.hpp"
#include "api/VehicleApiBase.hpp"
#include "api/VehicleSimApiBase.hpp"
#include "vehicles/multirotor/MultiRotorParams.hpp"
#include <vector>
#include "physics/PhysicsBody.hpp"
#include "JSBSim/FGFDMExec.h"
#include "JSBSim/initialization/FGInitialCondition.h"
#include "common/Common.hpp"
#include "common/AirSimSettings.hpp"

namespace msr
{
namespace airlib
{

    class JSBSimPhysicsBody : public PhysicsBody
    {
    public:
        JSBSimPhysicsBody(MultiRotorParams* params, VehicleApiBase* vehicle_api,
                          Kinematics* kinematics, Environment* environment, const AirSimSettings::VehicleSetting* vehicle_settings)
            : params_(params), vehicle_api_(vehicle_api)
        {
            setName("JSBSimPhysicsBody");
            vehicle_api_->setParent(this);
            vehicle_settings_ = vehicle_settings;
            initialize(kinematics, environment);
        }

        //*** Start: UpdatableState implementation ***//
        virtual void resetImplementation() override
        {
            //reset rotors, kinematics and environment
            PhysicsBody::resetImplementation();

            //reset sensors last after their ground truth has been reset
            resetSensors();
        }

        virtual void update() override
        {
            TTimeDelta dt = clock()->updateSince(this->last_kinematics_time);
            
            this->lock();
            //get current kinematics state of the body - this state existed since last dt seconds
            const Kinematics::State& current = this->getKinematics();
            Kinematics::State next;

            //first compute the response as if there was no collision
            //this is necessary to take in to account forces and torques generated by body
            getNextKinematicsNoCollision(dt, next, *jsbsim_aircraft);

            //if there is collision, see if we need collision response
            const CollisionInfo collision_info = this->getCollisionInfo();
            CollisionResponse& collision_response = this->getCollisionResponseInfo();
            bool is_collision_response = false;
            //if collision was already responded then do not respond to it until we get updated information
            if (this->isGrounded() || (collision_info.has_collided && collision_response.collision_time_stamp != collision_info.time_stamp)) {
                bool enable_ground_lock_ = false;
                is_collision_response = getNextKinematicsOnCollision(dt, collision_info, current, next, enable_ground_lock_);
                updateCollisionResponseInfo(collision_info, next, is_collision_response, collision_response);
                
            }

            //if there was a collision, restart the model using the computed collision kinematic
            if (is_collision_response) 
                restartModel(*jsbsim_aircraft, next);

            this->updateKinematics(next);
            this->unlock();

            //update forces on vertices that we will use next
            PhysicsBody::update();

            //Note that controller gets updated after kinematics gets updated in updateKinematics
            //otherwise sensors will have values from previous cycle causing lags which will appear
            //as crazy jerks whenever commands like velocity is issued
        }
        virtual void reportState(StateReporter& reporter) override
        {
            //call base
            PhysicsBody::reportState(reporter);

            reportSensors(*params_, reporter);

            //report rotors
            for (uint rotor_index = 0; rotor_index < rotors_.size(); ++rotor_index) {
                reporter.startHeading("", 1);
                reporter.writeValue("Rotor", rotor_index);
                reporter.endHeading(false, 1);
                rotors_.at(rotor_index).reportState(reporter);
            }
        }
        //*** End: UpdatableState implementation ***//

        //Fast Physics engine calls this method to set next kinematics
        virtual void updateKinematics(const Kinematics::State& kinematics) override
        {
            PhysicsBody::updateKinematics(kinematics);

            updateSensorsAndController();
        }

        //External Physics engine calls this method to keep physics bodies updated and move rotors
        virtual void updateKinematics() override
        {
            PhysicsBody::updateKinematics();

            updateSensorsAndController();
        }

        void updateSensorsAndController()
        {
            updateSensors(*params_, getKinematics(), getEnvironment());

            //update controller which will update actuator control signal
            vehicle_api_->update();  //take out

            //transfer new input values from controller to rotors
            for (uint rotor_index = 0; rotor_index < rotors_.size(); ++rotor_index) {
                rotors_.at(rotor_index).setControlSignal(vehicle_api_->getActuation(rotor_index)); //change reading rotors' input from JSBSim 
            }
        }

        //sensor getter
        const SensorCollection& getSensors() const
        {
            return params_->getSensors();
        }

        //physics body interface
        virtual uint wrenchVertexCount() const override
        {
            return params_->getParams().rotor_count;
        }
        virtual PhysicsBodyVertex& getWrenchVertex(uint index) override
        {
            return rotors_.at(index);
        }
        virtual const PhysicsBodyVertex& getWrenchVertex(uint index) const override
        {
            return rotors_.at(index);
        }

        virtual uint dragVertexCount() const override
        {
            return static_cast<uint>(drag_faces_.size());
        }
        virtual PhysicsBodyVertex& getDragVertex(uint index) override
        {
            return drag_faces_.at(index);
        }
        virtual const PhysicsBodyVertex& getDragVertex(uint index) const override
        {
            return drag_faces_.at(index);
        }

        virtual real_T getRestitution() const override
        {
            return params_->getParams().restitution;
        }
        virtual real_T getFriction() const override
        {
            return params_->getParams().friction;
        }

        RotorActuator::Output getRotorOutput(uint rotor_index) const
        {
            return rotors_.at(rotor_index).getOutput();
        }

        void setModelPath(std::string model_name)
        {
            model_name_ = model_name;
            if (model_name == "") {
                model_name_ = "c172x";
            }
        }

        void setPose(const Pose& pose)
        {
            PhysicsBody::setPose(pose);

            const SGPath ic_file("/* Insert path to initial condition file */");
            std::shared_ptr<JSBSim::FGInitialCondition> fgic = jsbsim_aircraft->GetIC();
            fgic->SetTerrainElevationFtIC(-10.0);
            setICPose(fgic, pose);

            const bool success = jsbsim_aircraft->RunIC(); // causes sim time to reset to 0.0, returns true if successful
            if (!success) {
                std::cout << "JSBSim failed to initialize simulation conditions" << std::endl;
            }
        }

        double getJSBSimProperty(const std::string& property_name)
        {
            // lock may not necessary here, we're not sure if getting property is thread-safe
            this->lock();
            double property_value = jsbsim_aircraft->GetPropertyValue(property_name);
            this->unlock();
            return property_value;
        }

        void setJSBSimProperty(const std::string& property_name, double property_value)
        {
            this->lock();
            jsbsim_aircraft->SetPropertyValue(property_name, property_value);
            this->unlock();
        }

        virtual ~JSBSimPhysicsBody() = default;

    protected:
        void loadJSBSimPaths(std::string model_path)
        {
            //SGPath aircraft_path("D:\\GitHubDesktop\\zimmy87\\jonyMarino-AirSim\\external\\jsbsim\\jsbsim-1.1.8\\aircraft");
            //SGPath engine_path("D:\\GitHubDesktop\\zimmy87\\jonyMarino-AirSim\\external\\jsbsim\\jsbsim-1.1.8\\engine");
            //SGPath system_path("D:\\GitHubDesktop\\zimmy87\\jonyMarino-AirSim\\external\\jsbsim\\jsbsim-1.1.8\\systems");
            SGPath aircraft_path("aircraft");
            SGPath engine_path("engine");
            SGPath system_path("systems");
            jsbsim_aircraft->LoadModel(aircraft_path, engine_path, system_path, model_path);
        }

    private: //methods
        void initialize(Kinematics* kinematics, Environment* environment)
        {
            PhysicsBody::initialize(params_->getParams().mass, params_->getParams().inertia, kinematics, environment);

            /* if (this->getKinematics().pose.position.z() == 0) {
                Kinematics::State state
                this->updateKinematics
            }*/

            float pitch, roll, yaw;
            roll = vehicle_settings_->rotation.roll;
            pitch = vehicle_settings_->rotation.pitch;
            yaw = vehicle_settings_->rotation.yaw;
            Quaternionr orientation = VectorMath::toQuaternion(pitch * deg_to_rad_, roll * deg_to_rad_, yaw * deg_to_rad_);
            //this->getKinematics().pos = orientation;

            createRotors(*params_, rotors_, environment);
            createDragVertices();

            initSensors(*params_, getKinematics(), getEnvironment());

            FString RelativePath = FPaths::ProjectDir();
            FString FullPath = IFileManager::Get().ConvertToAbsolutePathForExternalAppForRead(*RelativePath);
            std::string ProjectPath(TCHAR_TO_UTF8(*FullPath));

            jsbsim_aircraft = new JSBSim::FGFDMExec(nullptr, nullptr); // construct JSBSim FGFDMExec class
            //jsbsim_aircraft->SetRootDir(SGPath(ProjectPath + "../../../JSBSimConfig"));
            jsbsim_aircraft->SetRootDir(SGPath(ProjectPath + ((const AirSimSettings::JSBSimVehicleSetting*)vehicle_settings_)->jsbsim_setting.root_dir));
            jsbsim_aircraft->SetAircraftPath(SGPath("aircraft"));
            jsbsim_aircraft->SetEnginePath(SGPath("engine"));
            jsbsim_aircraft->SetSystemsPath(SGPath("systems"));
            setModelPath(((const AirSimSettings::JSBSimVehicleSetting*)vehicle_settings_)->jsbsim_setting.model_path);
            //loadJSBSimPaths(model_name_);
            //jsbsim_aircraft->LoadScript(SGPath("scripts/c172_elevation_test.xml"));
            //jsbsim_aircraft->LoadScript(SGPath("scripts/c172_airjsbsim_test.xml"));
            std::string script_path = ((const AirSimSettings::JSBSimVehicleSetting*)vehicle_settings_)->jsbsim_setting.script_path;
            if (script_path != "") {
                jsbsim_aircraft->LoadScript(SGPath(script_path));
            }
            //jsbsim_aircraft->LoadScript(SGPath("D:/GitHubDesktop/zimmy87/jonyMarino-AirSim/external/jsbsim/jsbsim-1.1.8/scripts/c172_elevation_test.xml"));
            // fgic->Load(ic_file);

            jsbsim_aircraft->Setdt(delta_t_);
        }

        static void createRotors(const MultiRotorParams& params, vector<RotorActuator>& rotors, const Environment* environment)
        {
            rotors.clear();
            //for each rotor pose
            for (uint rotor_index = 0; rotor_index < params.getParams().rotor_poses.size(); ++rotor_index) {
                const MultiRotorParams::RotorPose& rotor_pose = params.getParams().rotor_poses.at(rotor_index);
                rotors.emplace_back(rotor_pose.position, rotor_pose.normal, rotor_pose.direction, params.getParams().rotor_params, environment, rotor_index);
            }
        }

        void reportSensors(MultiRotorParams& params, StateReporter& reporter)
        {
            params.getSensors().reportState(reporter);
        }

        void updateSensors(MultiRotorParams& params, const Kinematics::State& state, const Environment& environment)
        {
            unused(state);
            unused(environment);
            params.getSensors().update();
        }

        void initSensors(MultiRotorParams& params, const Kinematics::State& state, const Environment& environment)
        {
            params.getSensors().initialize(&state, &environment);
        }

        void resetSensors()
        {
            params_->getSensors().reset();
        }

        void createDragVertices()
        {
            const auto& params = params_->getParams();

            //Drone is seen as central body that is connected to propellers via arm. We approximate central body as box of size x, y, z.
            //The drag depends on area exposed so we also add area of propellers to approximate drag they may introduce due to their area.
            //while moving along any axis, we find area that will be exposed in that direction
            real_T propeller_area = M_PIf * params.rotor_params.propeller_diameter * params.rotor_params.propeller_diameter;
            real_T propeller_xsection = M_PIf * params.rotor_params.propeller_diameter * params.rotor_params.propeller_height;

            real_T top_bottom_area = params.body_box.x() * params.body_box.y();
            real_T left_right_area = params.body_box.x() * params.body_box.z();
            real_T front_back_area = params.body_box.y() * params.body_box.z();
            Vector3r drag_factor_unit = Vector3r(
                                            front_back_area + rotors_.size() * propeller_xsection,
                                            left_right_area + rotors_.size() * propeller_xsection,
                                            top_bottom_area + rotors_.size() * propeller_area) *
                                        params.linear_drag_coefficient / 2;

            //add six drag vertices representing 6 sides
            drag_faces_.clear();
            drag_faces_.emplace_back(Vector3r(0, 0, -params.body_box.z() / 2.0f), Vector3r(0, 0, -1), drag_factor_unit.z());
            drag_faces_.emplace_back(Vector3r(0, 0, params.body_box.z() / 2.0f), Vector3r(0, 0, 1), drag_factor_unit.z());
            drag_faces_.emplace_back(Vector3r(0, -params.body_box.y() / 2.0f, 0), Vector3r(0, -1, 0), drag_factor_unit.y());
            drag_faces_.emplace_back(Vector3r(0, params.body_box.y() / 2.0f, 0), Vector3r(0, 1, 0), drag_factor_unit.y());
            drag_faces_.emplace_back(Vector3r(-params.body_box.x() / 2.0f, 0, 0), Vector3r(-1, 0, 0), drag_factor_unit.x());
            drag_faces_.emplace_back(Vector3r(params.body_box.x() / 2.0f, 0, 0), Vector3r(1, 0, 0), drag_factor_unit.x());
        }

        void getKinematicsFromModel(JSBSim::FGFDMExec& model, Kinematics::State& kinematics)
        {
            kinematics.pose.position = getJSBSimPosition(model);
            kinematics.pose.orientation = getJSBSimOrientation(model);
            kinematics.twist.linear = getJSBSimLinearVelocity(model);
            kinematics.twist.angular = getJSBSimAngularVelocity(model);
            kinematics.accelerations.linear = getJSBSimLinearAcceleration(model);
            kinematics.accelerations.angular = getJSBSimAngularAcceleration(model);
        }

        void restartModel(JSBSim::FGFDMExec& model, Kinematics::State& kinematics)
        {
            //setJSBSimPosition(model, kenematics.pose.position);
            //setJSBSimOrientation(model, kenematics.pose.orientation);
            //setJSBSimLinearVelocity(model,kenematics.twist.linear);
            //setJSBSimAngularVelocity(model,kenematics.twist.angular);
            //setJSBSimLinearAcceleration(model, kenematics.accelerations.linear);
            //setJSBSimAngularAcceleration(model, kenematics.accelerations.angular);
            std::shared_ptr<JSBSim::FGInitialCondition> fgic = model.GetIC();
            setICPose(fgic, kinematics.pose);

            fgic->SetVNorthFpsIC(kinematics.twist.linear.x() * meters_to_ft_);
            fgic->SetVEastFpsIC(kinematics.twist.linear.y() * meters_to_ft_);
            fgic->SetVDownFpsIC(kinematics.twist.linear.z() * meters_to_ft_);

            // angular velocity
            fgic->SetPRadpsIC(kinematics.twist.angular.x());
            fgic->SetQRadpsIC(kinematics.twist.angular.y());
            fgic->SetRRadpsIC(kinematics.twist.angular.z());

            model.RunIC();

            // for some use cases, a reset of the model is needed
            model.ResetToInitialConditions(0);
        }

        Vector3r getJSBSimLinearVelocity(JSBSim::FGFDMExec& model) 
        {
            double u = model.GetPropertyValue("velocities/u-fps") * 0.3048;
            double v = model.GetPropertyValue("velocities/v-fps") * 0.3048;
            double w = model.GetPropertyValue("velocities/w-fps") * 0.3048;

            return Vector3r(u, v, w);
        }
        
        Vector3r getJSBSimAngularVelocity(JSBSim::FGFDMExec& model) 
        { 
            double p = model.GetPropertyValue("velocities/p-rad_sec");
            double q = model.GetPropertyValue("velocities/q-rad_sec");
            double r = model.GetPropertyValue("velocities/r-rad_sec");

            return Vector3r(p, q, r);
        }
        
        Vector3r getJSBSimLinearAcceleration(JSBSim::FGFDMExec& model) 
        {
            double u = model.GetPropertyValue("accelerations/udot-ft_sec2") * 0.3048;
            double v = model.GetPropertyValue("accelerations/vdot-ft_sec2") * 0.3048;
            double w = model.GetPropertyValue("accelerations/wdot-ft_sec2") * 0.3048;

            return Vector3r(u, v, w);
        }
        Vector3r getJSBSimAngularAcceleration(JSBSim::FGFDMExec& model) 
        {
            double p = model.GetPropertyValue("accelerations/pdot-rad_sec2");
            double q = model.GetPropertyValue("accelerations/pdot-rad_sec2");
            double r = model.GetPropertyValue("accelerations/pdot-rad_sec2");

            return Vector3r(p, q, r);
        }

        Vector3r getJSBSimPosition(JSBSim::FGFDMExec& model)
        {
            double x = 111320 * model.GetPropertyValue("position/lat-geod-deg");
            double y = 40075000 * model.GetPropertyValue("position/long-gc-deg") * cos(model.GetPropertyValue("position/lat-geod-deg") * (M_PI / 180.0)) / 360;
            double z = model.GetPropertyValue("position/h-sl-meters");
            /* x = x - vehicle_settings_->position.x();
            y = y - vehicle_settings_->position.y();
            z = z - vehicle_settings_->position.z();*/
            return Vector3r(x, y, -z);
        }

        Quaternionr getJSBSimOrientation(JSBSim::FGFDMExec& model)
        {
            double pitch = model.GetPropertyValue("attitude/pitch-rad");
            double roll = model.GetPropertyValue("attitude/roll-rad");
            double yaw = model.GetPropertyValue("attitude/psi-deg") * (M_PI / 180.0);
            return VectorMath::toQuaternion(pitch, roll, yaw);        
        }

        void getNextKinematicsNoCollision(TTimeDelta dt, Kinematics::State& next, JSBSim::FGFDMExec& nextModel)
        {

            nextModel.Setdt(delta_t_); // shouldn't be using dt?
            nextModel.Run();

            getKinematicsFromModel(nextModel, next);

        }

        //return value indicates if collision response was generated
        bool getNextKinematicsOnCollision(TTimeDelta dt, const CollisionInfo& collision_info,
                                          const Kinematics::State& current, Kinematics::State& next, bool enable_ground_lock)
        {
            /************************* Collision response ************************/
            const real_T dt_real = static_cast<real_T>(dt);

            //are we going away from collision? if so then keep using computed next state
            if (collision_info.normal.dot(next.twist.linear) >= 0.0f)
                return false;

            /********** Core collision response ***********/
            //get avg current velocity
            const Vector3r vcur_avg = current.twist.linear + current.accelerations.linear * dt_real;

            //get average angular velocity
            const Vector3r angular_avg = current.twist.angular + current.accelerations.angular * dt_real;

            //contact point vector
            Vector3r r = collision_info.impact_point - collision_info.position;

            //see if impact is straight at body's surface (assuming its box)
            const Vector3r normal_body = VectorMath::transformToBodyFrame(collision_info.normal, current.pose.orientation);
            const bool is_ground_normal = Utils::isApproximatelyEqual(std::abs(normal_body.z()), 1.0f, kAxisTolerance);
            bool ground_collision = false;
            const float z_vel = vcur_avg.z();
            const bool is_landing = z_vel > std::abs(vcur_avg.x()) && z_vel > std::abs(vcur_avg.y());

            real_T restitution = this->getRestitution();
            real_T friction = this->getFriction();

            if (is_ground_normal && is_landing
                // So normal_body is the collision normal translated into body coords, why does an x==1 or y==1
                // mean we are coliding with the ground???
                // || Utils::isApproximatelyEqual(std::abs(normal_body.x()), 1.0f, kAxisTolerance)
                // || Utils::isApproximatelyEqual(std::abs(normal_body.y()), 1.0f, kAxisTolerance)
            ) {
                // looks like we are coliding with the ground.  We don't want the ground to be so bouncy
                // so we reduce the coefficient of restitution.  0 means no bounce.
                // TODO: it would be better if we did this based on the material we are landing on.
                // e.g. grass should be inelastic, but a hard surface like the road should be more bouncy.
                restitution = 0;
                // crank up friction with the ground so it doesn't try and slide across the ground
                // again, this should depend on the type of surface we are landing on.
                friction = 1;

                //we have collided with ground straight on, we will fix orientation later
                ground_collision = is_ground_normal;
            }

            //velocity at contact point
            const Vector3r vcur_avg_body = VectorMath::transformToBodyFrame(vcur_avg, current.pose.orientation);
            const Vector3r contact_vel_body = vcur_avg_body + angular_avg.cross(r);

            /*
            GafferOnGames - Collision response with columb friction
            http://gafferongames.com/virtual-go/collision-response-and-coulomb-friction/
            Assuming collision is with static fixed body,
            impulse magnitude = j = -(1 + R)V.N / (1/m + (I'(r X N) X r).N)
            Physics Part 3, Collision Response, Chris Hecker, eq 4(a)
            http://chrishecker.com/images/e/e7/Gdmphys3.pdf
            V(t+1) = V(t) + j*N / m
        */
            const real_T impulse_mag_denom = 1.0f / this->getMass() +
                                             (this->getInertiaInv() * r.cross(normal_body))
                                                 .cross(r)
                                                 .dot(normal_body);
            const real_T impulse_mag = -contact_vel_body.dot(normal_body) * (1 + restitution) / impulse_mag_denom;

            next.twist.linear = vcur_avg + collision_info.normal * (impulse_mag / this->getMass());
            next.twist.angular = angular_avg + r.cross(normal_body) * impulse_mag;

            //above would modify component in direction of normal
            //we will use friction to modify component in direction of tangent
            const Vector3r contact_tang_body = contact_vel_body - normal_body * normal_body.dot(contact_vel_body);
            const Vector3r contact_tang_unit_body = contact_tang_body.normalized();
            const real_T friction_mag_denom = 1.0f / this->getMass() +
                                              (this->getInertiaInv() * r.cross(contact_tang_unit_body))
                                                  .cross(r)
                                                  .dot(contact_tang_unit_body);
            const real_T friction_mag = -contact_tang_body.norm() * friction / friction_mag_denom;

            const Vector3r contact_tang_unit = VectorMath::transformToWorldFrame(contact_tang_unit_body, current.pose.orientation);
            next.twist.linear += contact_tang_unit * friction_mag;
            next.twist.angular += r.cross(contact_tang_unit_body) * (friction_mag / this->getMass());

            //TODO: implement better rolling friction
            next.twist.angular *= 0.9f;

            // there is no acceleration during collision response, this is a hack, but without it the acceleration cancels
            // the computed impulse response too much and stops the vehicle from bouncing off the collided object.
            next.accelerations.linear = Vector3r::Zero();
            next.accelerations.angular = Vector3r::Zero();

            next.pose = current.pose;
            if (enable_ground_lock && ground_collision) {
                float pitch, roll, yaw;
                VectorMath::toEulerianAngle(next.pose.orientation, pitch, roll, yaw);
                pitch = roll = 0;
                next.pose.orientation = VectorMath::toQuaternion(pitch, roll, yaw);

                //there is a lot of random angular velocity when vehicle is on the ground
                next.twist.angular = Vector3r::Zero();

                // also eliminate any linear velocity due to twist - since we are sitting on the ground there shouldn't be any.
                next.twist.linear = Vector3r::Zero();
                next.pose.position = collision_info.position;
                this->setGrounded(true);

                // but we do want to "feel" the ground when we hit it (we should see a small z-acc bump)
                // equal and opposite our downward velocity.
                next.accelerations.linear = -0.5f * this->getMass() * vcur_avg;

                //throttledLogOutput("*** Triggering ground lock", 0.1);
            }
            else {
                //else keep the orientation
                next.pose.position = collision_info.position + (collision_info.normal * collision_info.penetration_depth) + next.twist.linear * (dt_real * kCollisionResponseCycles);
            }
            

            //Utils::log(Utils::stringf("*** C-VEL %s: ", VectorMath::toString(next.twist.linear).c_str()));

            return true;
        }

        static void updateCollisionResponseInfo(const CollisionInfo& collision_info, const Kinematics::State& next,
                                                bool is_collision_response, CollisionResponse& collision_response)
        {
            collision_response.collision_time_stamp = collision_info.time_stamp;
            ++collision_response.collision_count_raw;

            //increment counter if we didn't collided with high velocity (like resting on ground)
            if (is_collision_response && next.twist.linear.squaredNorm() > kRestingVelocityMax * kRestingVelocityMax)
                ++collision_response.collision_count_non_resting;
        }

        void setICPose(std::shared_ptr<JSBSim::FGInitialCondition> fgic, Pose pose)
        {
            //Pose pose = this->getKinematics().pose;
            Vector3r position = pose.position;
            /* float x = position.x() + vehicle_settings_->position.x();
            float y = position.y() + vehicle_settings_->position.y();
            float z = position.z() + vehicle_settings_->position.z();*/
            float x = position.x();
            float y = position.y();
            float z = position.z();
            Quaternionr orientation = pose.orientation;
            float pitch, roll, yaw;
            VectorMath::toEulerianAngle(orientation, pitch, roll, yaw);

            // Set position
            fgic->SetAltitudeASLFtIC((-z * meters_to_ft_)); // need to offset initial position because of bug in JSBSim when altitude = 0
            //fgic->SetAltitudeASLFtIC(10.0);
            double latitude = x / 111320;
            fgic->SetGeodLatitudeDegIC(latitude);
            // 40075000 * model.GetPropertyValue("position/long-gc-deg") * cos(model.GetPropertyValue("position/lat-geod-deg") * (M_PI / 180.0)) / 360;
            fgic->SetLongitudeDegIC(y / (40075000 * cos(latitude * (M_PI / 180.0)) / 360));

            // Set orientation
            /* fgic->SetPhiDegIC(roll * rad_to_deg_ + vehicle_settings_->rotation.roll);
            fgic->SetThetaDegIC(pitch * rad_to_deg_ + vehicle_settings_->rotation.pitch);
            fgic->SetPsiDegIC(yaw * rad_to_deg_ + vehicle_settings_->rotation.yaw);*/
            fgic->SetPhiDegIC(roll * rad_to_deg_);
            fgic->SetThetaDegIC(pitch * rad_to_deg_);
            fgic->SetPsiDegIC(yaw * rad_to_deg_);
        }

    private: //fields
        MultiRotorParams* params_;

        //let us be the owner of rotors object
        vector<RotorActuator> rotors_;
        vector<PhysicsBodyVertex> drag_faces_;

        std::unique_ptr<Environment> environment_;
        VehicleApiBase* vehicle_api_;

        JSBSim::FGFDMExec* jsbsim_aircraft;
        std::string model_name_;
        double delta_t_ = 0.0021; // set the simulation update rate, defaults to 480Hz

        static constexpr float kRestingVelocityMax = 0.1f;
        static constexpr float kAxisTolerance = 0.25f;
        static constexpr uint kCollisionResponseCycles = 1;

        const AirSimSettings::VehicleSetting* vehicle_settings_;
        const double meters_to_ft_ = 3.28084;
        const double rad_to_deg_ = (180.0 / M_PI);
        const double deg_to_rad_ = (M_PI / 180.0);
    };
}
} //namespace
#endif
